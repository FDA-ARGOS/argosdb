// Generated with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: lib
'use strict';

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _extends2() { _extends2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends2.apply(this, arguments); }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var React = require('react');

var escapeHtml = require('escape-html');

function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var escapeHtml__default = /*#__PURE__*/_interopDefaultLegacy(escapeHtml);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function Element(_ref) {
  var _ref$attributes = _ref.attributes,
      attributes = _ref$attributes === void 0 ? {} : _ref$attributes,
      className = _ref.className,
      _ref$children = _ref.children,
      children = _ref$children === void 0 ? null : _ref$children,
      _ref$selfClose = _ref.selfClose,
      selfClose = _ref$selfClose === void 0 ? false : _ref$selfClose,
      tagName = _ref.tagName;
  var Tag = tagName;
  return selfClose ? /*#__PURE__*/React__default['default'].createElement(Tag, _extends({
    className: className
  }, attributes)) : /*#__PURE__*/React__default['default'].createElement(Tag, _extends({
    className: className
  }, attributes), children);
}

var Filter = /*#__PURE__*/function () {
  function Filter() {}

  var _proto = Filter.prototype;

  /**
   * Filter and clean an HTML attribute value.
   */
  _proto.attribute = function attribute(name, value) {
    return value;
  }
  /**
   * Filter and clean an HTML node.
   */
  ;

  _proto.node = function node(name, _node) {
    return _node;
  };

  return Filter;
}();
/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */
// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories


var TYPE_FLOW = 1;
var TYPE_SECTION = 1 << 1;
var TYPE_HEADING = 1 << 2;
var TYPE_PHRASING = 1 << 3;
var TYPE_EMBEDDED = 1 << 4;
var TYPE_INTERACTIVE = 1 << 5;
var TYPE_PALPABLE = 1 << 6; // https://developer.mozilla.org/en-US/docs/Web/HTML/Element

var tagConfigs = {
  a: {
    content: TYPE_FLOW | TYPE_PHRASING,
    self: false,
    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE
  },
  address: {
    invalid: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'address', 'article', 'aside', 'section', 'div', 'header', 'footer'],
    self: false
  },
  audio: {
    children: ['track', 'source']
  },
  br: {
    type: TYPE_FLOW | TYPE_PHRASING,
    void: true
  },
  body: {
    content: TYPE_FLOW | TYPE_SECTION | TYPE_HEADING | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_INTERACTIVE | TYPE_PALPABLE
  },
  button: {
    content: TYPE_PHRASING,
    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE
  },
  caption: {
    content: TYPE_FLOW,
    parent: ['table']
  },
  col: {
    parent: ['colgroup'],
    void: true
  },
  colgroup: {
    children: ['col'],
    parent: ['table']
  },
  details: {
    children: ['summary'],
    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE
  },
  dd: {
    content: TYPE_FLOW,
    parent: ['dl']
  },
  dl: {
    children: ['dt', 'dd'],
    type: TYPE_FLOW
  },
  dt: {
    content: TYPE_FLOW,
    invalid: ['footer', 'header'],
    parent: ['dl']
  },
  figcaption: {
    content: TYPE_FLOW,
    parent: ['figure']
  },
  footer: {
    invalid: ['footer', 'header']
  },
  header: {
    invalid: ['footer', 'header']
  },
  hr: {
    type: TYPE_FLOW,
    void: true
  },
  img: {
    void: true
  },
  li: {
    content: TYPE_FLOW,
    parent: ['ul', 'ol', 'menu']
  },
  main: {
    self: false
  },
  ol: {
    children: ['li'],
    type: TYPE_FLOW
  },
  picture: {
    children: ['source', 'img'],
    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED
  },
  rb: {
    parent: ['ruby', 'rtc']
  },
  rp: {
    parent: ['ruby', 'rtc']
  },
  rt: {
    content: TYPE_PHRASING,
    parent: ['ruby', 'rtc']
  },
  rtc: {
    content: TYPE_PHRASING,
    parent: ['ruby']
  },
  ruby: {
    children: ['rb', 'rp', 'rt', 'rtc']
  },
  source: {
    parent: ['audio', 'video', 'picture'],
    void: true
  },
  summary: {
    content: TYPE_PHRASING,
    parent: ['details']
  },
  table: {
    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],
    type: TYPE_FLOW
  },
  tbody: {
    parent: ['table'],
    children: ['tr']
  },
  td: {
    content: TYPE_FLOW,
    parent: ['tr']
  },
  tfoot: {
    parent: ['table'],
    children: ['tr']
  },
  th: {
    content: TYPE_FLOW,
    parent: ['tr']
  },
  thead: {
    parent: ['table'],
    children: ['tr']
  },
  tr: {
    parent: ['table', 'tbody', 'thead', 'tfoot'],
    children: ['th', 'td']
  },
  track: {
    parent: ['audio', 'video'],
    void: true
  },
  ul: {
    children: ['li'],
    type: TYPE_FLOW
  },
  video: {
    children: ['track', 'source']
  },
  wbr: {
    type: TYPE_FLOW | TYPE_PHRASING,
    void: true
  }
};

function createConfigBuilder(config) {
  return function (tagName) {
    tagConfigs[tagName] = _extends2({}, config, tagConfigs[tagName]);
  };
}

['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(createConfigBuilder({
  content: TYPE_FLOW,
  type: TYPE_FLOW | TYPE_PALPABLE
}));
['abbr', 'b', 'bdi', 'bdo', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'ruby', 'samp', 'strong', 'sub', 'sup', 'time', 'u', 'var'].forEach(createConfigBuilder({
  content: TYPE_PHRASING,
  type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE
}));
['p', 'pre'].forEach(createConfigBuilder({
  content: TYPE_PHRASING,
  type: TYPE_FLOW | TYPE_PALPABLE
}));
['s', 'small', 'span', 'del', 'ins'].forEach(createConfigBuilder({
  content: TYPE_PHRASING,
  type: TYPE_FLOW | TYPE_PHRASING
}));
['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(createConfigBuilder({
  content: TYPE_FLOW,
  type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE
}));
['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(createConfigBuilder({
  content: TYPE_PHRASING,
  type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE
}));
['audio', 'canvas', 'iframe', 'img', 'video'].forEach(createConfigBuilder({
  type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE
})); // Disable this map from being modified

var TAGS = Object.freeze(tagConfigs); // Tags that should never be allowed, even if the allow list is disabled

var BANNED_TAG_LIST = ['applet', 'base', 'body', 'command', 'embed', 'frame', 'frameset', 'head', 'html', 'link', 'meta', 'noscript', 'object', 'script', 'style', 'title'];
var ALLOWED_TAG_LIST = Object.keys(TAGS).filter(function (tag) {
  return tag !== 'canvas' && tag !== 'iframe';
}); // Filters apply to HTML attributes

var FILTER_ALLOW = 1;
var FILTER_DENY = 2;
var FILTER_CAST_NUMBER = 3;
var FILTER_CAST_BOOL = 4;
var FILTER_NO_CAST = 5; // Attributes not listed here will be denied
// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes

var ATTRIBUTES = Object.freeze({
  alt: FILTER_ALLOW,
  cite: FILTER_ALLOW,
  class: FILTER_ALLOW,
  colspan: FILTER_CAST_NUMBER,
  controls: FILTER_CAST_BOOL,
  datetime: FILTER_ALLOW,
  default: FILTER_CAST_BOOL,
  disabled: FILTER_CAST_BOOL,
  dir: FILTER_ALLOW,
  height: FILTER_ALLOW,
  href: FILTER_ALLOW,
  id: FILTER_ALLOW,
  kind: FILTER_ALLOW,
  label: FILTER_ALLOW,
  lang: FILTER_ALLOW,
  loading: FILTER_ALLOW,
  loop: FILTER_CAST_BOOL,
  media: FILTER_ALLOW,
  muted: FILTER_CAST_BOOL,
  poster: FILTER_ALLOW,
  role: FILTER_ALLOW,
  rowspan: FILTER_CAST_NUMBER,
  scope: FILTER_ALLOW,
  sizes: FILTER_ALLOW,
  span: FILTER_CAST_NUMBER,
  start: FILTER_CAST_NUMBER,
  style: FILTER_NO_CAST,
  src: FILTER_ALLOW,
  srclang: FILTER_ALLOW,
  srcset: FILTER_ALLOW,
  target: FILTER_ALLOW,
  title: FILTER_ALLOW,
  type: FILTER_ALLOW,
  width: FILTER_ALLOW
}); // Attributes to camel case for React props

var ATTRIBUTES_TO_PROPS = Object.freeze({
  class: 'className',
  colspan: 'colSpan',
  datetime: 'dateTime',
  rowspan: 'rowSpan',
  srclang: 'srcLang',
  srcset: 'srcSet'
});
var INVALID_STYLES = /(url|image|image-set)\(/i;

var StyleFilter = /*#__PURE__*/function (_Filter) {
  _inheritsLoose(StyleFilter, _Filter);

  function StyleFilter() {
    return _Filter.apply(this, arguments) || this;
  }

  var _proto2 = StyleFilter.prototype;

  _proto2.attribute = function attribute(name, value) {
    if (name === 'style') {
      Object.keys(value).forEach(function (key) {
        if (String(value[key]).match(INVALID_STYLES)) {
          // eslint-disable-next-line no-param-reassign
          delete value[key];
        }
      });
    }

    return value;
  };

  return StyleFilter;
}(Filter);
/* eslint-disable no-bitwise, no-cond-assign, complexity */


var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var INVALID_ROOTS = /^<(!doctype|(html|head|body)(\s|>))/i;
var ALLOWED_ATTRS = /^(aria\x2D|data\x2D|[0-9A-Z_a-z\u017F\u212A]+:)/i;
var OPEN_TOKEN = /{{{(\w+)\/?}}}/;

function createDocument() {
  // Maybe SSR? Just do nothing instead of crashing!
  if (typeof window === 'undefined' || typeof document === 'undefined') {
    return undefined;
  }

  return document.implementation.createHTMLDocument('Interweave');
}

var Parser = /*#__PURE__*/function () {
  function Parser(markup, props, matchers, filters) {
    if (props === void 0) {
      props = {};
    }

    if (matchers === void 0) {
      matchers = [];
    }

    if (filters === void 0) {
      filters = [];
    }

    this.allowed = void 0;
    this.banned = void 0;
    this.blocked = void 0;
    this.container = void 0;
    this.content = [];
    this.props = void 0;
    this.matchers = void 0;
    this.filters = void 0;
    this.keyIndex = void 0;

    if (process.env.NODE_ENV !== "production") {
      if (markup && typeof markup !== 'string') {
        throw new TypeError('Interweave parser requires a valid string.');
      }
    }

    this.props = props;
    this.matchers = matchers;
    this.filters = [].concat(filters, [new StyleFilter()]);
    this.keyIndex = -1;
    this.container = this.createContainer(markup || '');
    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);
    this.banned = new Set(BANNED_TAG_LIST);
    this.blocked = new Set(props.blockList);
  }
  /**
   * Loop through and apply all registered attribute filters.
   */


  var _proto3 = Parser.prototype;

  _proto3.applyAttributeFilters = function applyAttributeFilters(name, value) {
    return this.filters.reduce(function (nextValue, filter) {
      return nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;
    }, value);
  }
  /**
   * Loop through and apply all registered node filters.
   */
  ;

  _proto3.applyNodeFilters = function applyNodeFilters(name, node) {
    // Allow null to be returned
    return this.filters.reduce(function (nextNode, filter) {
      return nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;
    }, node);
  }
  /**
   * Loop through and apply all registered matchers to the string.
   * If a match is found, create a React element, and build a new array.
   * This array allows React to interpolate and render accordingly.
   */
  ;

  _proto3.applyMatchers = function applyMatchers(string, parentConfig) {
    var _this = this;

    var elements = {};
    var props = this.props;
    var matchedString = string;
    var elementIndex = 0;
    var parts = null;
    this.matchers.forEach(function (matcher) {
      var tagName = matcher.asTag().toLowerCase();

      var config = _this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported


      if (props[matcher.inverseName] || !_this.isTagAllowed(tagName)) {
        return;
      } // Skip matchers in which the child cannot be rendered


      if (!_this.canRenderChild(parentConfig, config)) {
        return;
      } // Continuously trigger the matcher until no matches are found


      var tokenizedString = '';

      while (matchedString && (parts = matcher.match(matchedString))) {
        var _parts = parts,
            index = _parts.index,
            length = _parts.length,
            _match = _parts.match,
            valid = _parts.valid,
            isVoid = _parts.void,
            partProps = _objectWithoutPropertiesLoose(_parts, ["index", "length", "match", "valid", "void"]);

        var tokenName = matcher.propName + elementIndex; // Piece together a new string with interpolated tokens

        if (index > 0) {
          tokenizedString += matchedString.slice(0, index);
        }

        if (valid) {
          tokenizedString += isVoid ? "{{{" + tokenName + "/}}}" : "{{{" + tokenName + "}}}" + _match + "{{{/" + tokenName + "}}}";
          _this.keyIndex += 1;
          elementIndex += 1;
          elements[tokenName] = {
            children: _match,
            matcher: matcher,
            props: _extends2({}, props, partProps, {
              key: _this.keyIndex
            })
          };
        } else {
          tokenizedString += _match;
        } // Reduce the string being matched against,
        // otherwise we end up in an infinite loop!


        if (matcher.greedy) {
          matchedString = tokenizedString + matchedString.slice(index + length);
          tokenizedString = '';
        } else {
          // eslint-disable-next-line unicorn/explicit-length-check
          matchedString = matchedString.slice(index + (length || _match.length));
        }
      } // Update the matched string with the tokenized string,
      // so that the next matcher can apply to it.


      if (!matcher.greedy) {
        matchedString = tokenizedString + matchedString;
      }
    });

    if (elementIndex === 0) {
      return string;
    }

    return this.replaceTokens(matchedString, elements);
  }
  /**
   * Determine whether the child can be rendered within the parent.
   */
  ;

  _proto3.canRenderChild = function canRenderChild(parentConfig, childConfig) {
    if (!parentConfig.tagName || !childConfig.tagName) {
      return false;
    } // No children


    if (parentConfig.void) {
      return false;
    } // Valid children


    if (parentConfig.children.length > 0) {
      return parentConfig.children.includes(childConfig.tagName);
    }

    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {
      return false;
    } // Valid parent


    if (childConfig.parent.length > 0) {
      return childConfig.parent.includes(parentConfig.tagName);
    } // Self nesting


    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {
      return false;
    } // Content category type


    return Boolean(parentConfig && parentConfig.content & childConfig.type);
  }
  /**
   * Convert line breaks in a string to HTML `<br/>` tags.
   * If the string contains HTML, we should not convert anything,
   * as line breaks should be handled by `<br/>`s in the markup itself.
   */
  ;

  _proto3.convertLineBreaks = function convertLineBreaks(markup) {
    var _this$props = this.props,
        noHtml = _this$props.noHtml,
        disableLineBreaks = _this$props.disableLineBreaks;

    if (noHtml || disableLineBreaks || markup.match(/<((?:\/[ a-z]+)|(?:[ a-z]+\/))>/gi)) {
      return markup;
    } // Replace carriage returns


    var nextMarkup = markup.replace(/\r\n/g, '\n'); // Replace long line feeds

    nextMarkup = nextMarkup.replace(/\n{3,}/g, '\n\n\n'); // Replace line feeds with `<br/>`s

    nextMarkup = nextMarkup.replace(/\n/g, '<br/>');
    return nextMarkup;
  }
  /**
   * Create a detached HTML document that allows for easy HTML
   * parsing while not triggering scripts or loading external
   * resources.
   */
  ;

  _proto3.createContainer = function createContainer(markup) {
    var factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;
    var doc = factory();

    if (!doc) {
      return undefined;
    }

    var tag = this.props.containerTagName || 'body';
    var el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);

    if (markup.match(INVALID_ROOTS)) {
      if (process.env.NODE_ENV !== "production") {
        throw new Error('HTML documents as Interweave content are not supported.');
      }
    } else {
      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml__default['default'](markup) : markup);
    }

    return el;
  }
  /**
   * Convert an elements attribute map to an object map.
   * Returns null if no attributes are defined.
   */
  ;

  _proto3.extractAttributes = function extractAttributes(node) {
    var _this2 = this;

    var allowAttributes = this.props.allowAttributes;
    var attributes = {};
    var count = 0;

    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {
      return null;
    }

    Array.from(node.attributes).forEach(function (attr) {
      var name = attr.name,
          value = attr.value;
      var newName = name.toLowerCase();
      var filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks

      if (!_this2.isSafe(node)) {
        return;
      } // Do not allow denied attributes, excluding ARIA attributes
      // Do not allow events or XSS injections


      if (!newName.match(ALLOWED_ATTRS)) {
        if (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\s|\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {
          return;
        }
      } // Apply attribute filters


      var newValue = newName === 'style' ? _this2.extractStyleAttribute(node) : value; // Cast to boolean

      if (filter === FILTER_CAST_BOOL) {
        newValue = true; // Cast to number
      } else if (filter === FILTER_CAST_NUMBER) {
        newValue = Number.parseFloat(String(newValue)); // Cast to string
      } else if (filter !== FILTER_NO_CAST) {
        newValue = String(newValue);
      }

      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = _this2.applyAttributeFilters(newName, newValue);
      count += 1;
    });

    if (count === 0) {
      return null;
    }

    return attributes;
  }
  /**
   * Extract the style attribute as an object and remove values that allow for attack vectors.
   */
  ;

  _proto3.extractStyleAttribute = function extractStyleAttribute(node) {
    var styles = {};
    Array.from(node.style).forEach(function (key) {
      var value = node.style[key];

      if (typeof value === 'string' || typeof value === 'number') {
        styles[key.replace(/-([a-z])/g, function (match, letter) {
          return letter.toUpperCase();
        })] = value;
      }
    });
    return styles;
  }
  /**
   * Return configuration for a specific tag.
   */
  ;

  _proto3.getTagConfig = function getTagConfig(tagName) {
    var common = {
      children: [],
      content: 0,
      invalid: [],
      parent: [],
      self: true,
      tagName: '',
      type: 0,
      void: false
    }; // Only spread when a tag config exists,
    // otherwise we use the empty `tagName`
    // for parent config inheritance.

    if (TAGS[tagName]) {
      return _extends2({}, common, TAGS[tagName], {
        tagName: tagName
      });
    }

    return common;
  }
  /**
   * Verify that a node is safe from XSS and injection attacks.
   */
  ;

  _proto3.isSafe = function isSafe(node) {
    // URLs should only support HTTP, email and phone numbers
    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {
      var href = node.getAttribute('href'); // Fragment protocols start with about:
      // So let's just allow them

      if (href && href.charAt(0) === '#') {
        return true;
      }

      var protocol = node.protocol.toLowerCase();
      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';
    }

    return true;
  }
  /**
   * Verify that an HTML tag is allowed to render.
   */
  ;

  _proto3.isTagAllowed = function isTagAllowed(tagName) {
    if (this.banned.has(tagName) || this.blocked.has(tagName)) {
      return false;
    }

    return this.props.allowElements || this.allowed.has(tagName);
  }
  /**
   * Parse the markup by injecting it into a detached document,
   * while looping over all child nodes and generating an
   * array to interpolate into JSX.
   */
  ;

  _proto3.parse = function parse() {
    if (!this.container) {
      return [];
    }

    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));
  }
  /**
   * Loop over the nodes children and generate a
   * list of text nodes and React elements.
   */
  ;

  _proto3.parseNode = function parseNode(parentNode, parentConfig) {
    var _this3 = this;

    var _this$props2 = this.props,
        noHtml = _this$props2.noHtml,
        noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,
        allowElements = _this$props2.allowElements,
        transform = _this$props2.transform,
        transformOnlyAllowList = _this$props2.transformOnlyAllowList;
    var content = [];
    var mergedText = '';
    Array.from(parentNode.childNodes).forEach(function (node) {
      // Create React elements from HTML elements
      if (node.nodeType === ELEMENT_NODE) {
        var tagName = node.nodeName.toLowerCase();

        var config = _this3.getTagConfig(tagName); // Persist any previous text


        if (mergedText) {
          content.push(mergedText);
          mergedText = '';
        } // Apply node filters first


        var nextNode = _this3.applyNodeFilters(tagName, node);

        if (!nextNode) {
          return;
        } // Apply transformation second


        var children;

        if (transform && !(transformOnlyAllowList && !_this3.isTagAllowed(tagName))) {
          _this3.keyIndex += 1;
          var key = _this3.keyIndex; // Must occur after key is set

          children = _this3.parseNode(nextNode, config);
          var transformed = transform(nextNode, children, config);

          if (transformed === null) {
            return;
          } else if (typeof transformed !== 'undefined') {
            content.push( /*#__PURE__*/React__default['default'].cloneElement(transformed, {
              key: key
            }));
            return;
          } // Reset as we're not using the transformation


          _this3.keyIndex = key - 1;
        } // Never allow these tags (except via a transformer)


        if (_this3.banned.has(tagName)) {
          return;
        } // Only render when the following criteria is met:
        //  - HTML has not been disabled
        //  - Tag is allowed
        //  - Child is valid within the parent


        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && _this3.isTagAllowed(tagName) && (allowElements || _this3.canRenderChild(parentConfig, config))) {
          _this3.keyIndex += 1; // Build the props as it makes it easier to test

          var attributes = _this3.extractAttributes(nextNode);

          var elementProps = {
            tagName: tagName
          };

          if (attributes) {
            elementProps.attributes = attributes;
          }

          if (config.void) {
            elementProps.selfClose = config.void;
          }

          content.push( /*#__PURE__*/React__default['default'].createElement(Element, _extends2({}, elementProps, {
            key: _this3.keyIndex
          }), children || _this3.parseNode(nextNode, config))); // Render the children of the current element only.
          // Important: If the current element is not allowed,
          // use the parent element for the next scope.
        } else {
          content = content.concat(_this3.parseNode(nextNode, config.tagName ? config : parentConfig));
        } // Apply matchers if a text node

      } else if (node.nodeType === TEXT_NODE) {
        var text = noHtml && !noHtmlExceptMatchers ? node.textContent : _this3.applyMatchers(node.textContent || '', parentConfig);

        if (Array.isArray(text)) {
          content = content.concat(text);
        } else {
          mergedText += text;
        }
      }
    });

    if (mergedText) {
      content.push(mergedText);
    }

    return content;
  }
  /**
   * Deconstruct the string into an array, by replacing custom tokens with React elements,
   * so that React can render it correctly.
   */
  ;

  _proto3.replaceTokens = function replaceTokens(tokenizedString, elements) {
    if (!tokenizedString.includes('{{{')) {
      return tokenizedString;
    }

    var nodes = [];
    var text = tokenizedString;
    var open = null; // Find an open token tag

    while (open = text.match(OPEN_TOKEN)) {
      var _open = open,
          _match2 = _open[0],
          tokenName = _open[1];
      var startIndex = open.index;

      var isVoid = _match2.includes('/');

      if (process.env.NODE_ENV !== "production") {
        if (!elements[tokenName]) {
          throw new Error("Token \"" + tokenName + "\" found but no matching element to replace with.");
        }
      } // Extract the previous non-token text


      if (startIndex > 0) {
        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening

        text = text.slice(startIndex);
      }

      var _elements$tokenName = elements[tokenName],
          children = _elements$tokenName.children,
          matcher = _elements$tokenName.matcher,
          elementProps = _elements$tokenName.props;
      var endIndex = void 0; // Use tag as-is if void

      if (isVoid) {
        endIndex = _match2.length;
        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void
      } else {
        var close = text.match(new RegExp("{{{/" + tokenName + "}}}"));

        if (process.env.NODE_ENV !== "production") {
          if (!close) {
            throw new Error("Closing token missing for interpolated element \"" + tokenName + "\".");
          }
        }

        endIndex = close.index + close[0].length;
        nodes.push(matcher.createElement(this.replaceTokens(text.slice(_match2.length, close.index), elements), elementProps));
      } // Reduce text for the next interation


      text = text.slice(endIndex);
    } // Extra the remaining text


    if (text.length > 0) {
      nodes.push(text);
    } // Reduce to a string if possible


    if (nodes.length === 0) {
      return '';
    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {
      return nodes[0];
    }

    return nodes;
  };

  return Parser;
}();
/* eslint-disable react/jsx-fragments */


function Markup(props) {
  var attributes = props.attributes,
      className = props.className,
      containerTagName = props.containerTagName,
      content = props.content,
      emptyContent = props.emptyContent,
      parsedContent = props.parsedContent,
      tagName = props.tagName;
  var tag = containerTagName || tagName || 'span';
  var noWrap = tag === 'fragment' ? true : props.noWrap;
  var mainContent;

  if (parsedContent) {
    mainContent = parsedContent;
  } else {
    var markup = new Parser(content || '', props).parse();

    if (markup.length > 0) {
      mainContent = markup;
    }
  }

  if (!mainContent) {
    mainContent = emptyContent;
  }

  if (noWrap) {
    // eslint-disable-next-line react/jsx-no-useless-fragment
    return /*#__PURE__*/React__default['default'].createElement(React__default['default'].Fragment, null, mainContent);
  }

  return /*#__PURE__*/React__default['default'].createElement(Element, {
    attributes: attributes,
    className: className,
    tagName: tag
  }, mainContent);
}

function Interweave(props) {
  var attributes = props.attributes,
      className = props.className,
      _props$content = props.content,
      content = _props$content === void 0 ? '' : _props$content,
      _props$disableFilters = props.disableFilters,
      disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,
      _props$disableMatcher = props.disableMatchers,
      disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,
      _props$emptyContent = props.emptyContent,
      emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,
      _props$filters = props.filters,
      filters = _props$filters === void 0 ? [] : _props$filters,
      _props$matchers = props.matchers,
      matchers = _props$matchers === void 0 ? [] : _props$matchers,
      _props$onAfterParse = props.onAfterParse,
      onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,
      _props$onBeforeParse = props.onBeforeParse,
      onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,
      _props$tagName = props.tagName,
      tagName = _props$tagName === void 0 ? 'span' : _props$tagName,
      _props$noWrap = props.noWrap,
      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,
      parserProps = _objectWithoutPropertiesLoose(props, ["attributes", "className", "content", "disableFilters", "disableMatchers", "emptyContent", "filters", "matchers", "onAfterParse", "onBeforeParse", "tagName", "noWrap"]);

  var allMatchers = disableMatchers ? [] : matchers;
  var allFilters = disableFilters ? [] : filters;
  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];
  var afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers

  allMatchers.forEach(function (matcher) {
    if (matcher.onBeforeParse) {
      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));
    }

    if (matcher.onAfterParse) {
      afterCallbacks.push(matcher.onAfterParse.bind(matcher));
    }
  }); // Trigger before callbacks

  var markup = beforeCallbacks.reduce(function (string, callback) {
    var nextString = callback(string, props);

    if (process.env.NODE_ENV !== "production") {
      if (typeof nextString !== 'string') {
        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');
      }
    }

    return nextString;
  }, content || ''); // Parse the markup

  var parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks

  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {
    var nextNodes = callback(parserNodes, props);

    if (process.env.NODE_ENV !== "production") {
      if (!Array.isArray(nextNodes)) {
        throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');
      }
    }

    return nextNodes;
  }, parser.parse());
  return /*#__PURE__*/React__default['default'].createElement(Markup, {
    attributes: attributes,
    className: className,
    containerTagName: props.containerTagName,
    emptyContent: emptyContent,
    tagName: tagName,
    noWrap: noWrap,
    parsedContent: nodes.length === 0 ? undefined : nodes
  });
}
/**
 * Trigger the actual pattern match and package the matched
 * response through a callback.
 */


function match(string, pattern, callback, isVoid) {
  if (isVoid === void 0) {
    isVoid = false;
  }

  var matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));

  if (!matches) {
    return null;
  }

  return _extends2({
    match: matches[0],
    void: isVoid
  }, callback(matches), {
    index: matches.index,
    length: matches[0].length,
    valid: true
  });
}

var Matcher = /*#__PURE__*/function () {
  function Matcher(name, options, factory) {
    this.greedy = false;
    this.options = void 0;
    this.propName = void 0;
    this.inverseName = void 0;
    this.factory = void 0;

    if (process.env.NODE_ENV !== "production") {
      if (!name || name.toLowerCase() === 'html') {
        throw new Error("The matcher name \"" + name + "\" is not allowed.");
      }
    } // @ts-expect-error


    this.options = _extends2({}, options);
    this.propName = name;
    this.inverseName = "no" + (name.charAt(0).toUpperCase() + name.slice(1));
    this.factory = factory || null;
  }
  /**
   * Attempts to create a React element using a custom user provided factory,
   * or the default matcher factory.
   */


  var _proto4 = Matcher.prototype;

  _proto4.createElement = function createElement(children, props) {
    var element = this.factory ? /*#__PURE__*/React__default['default'].createElement(this.factory, props, children) : this.replaceWith(children, props);

    if (process.env.NODE_ENV !== "production") {
      if (typeof element !== 'string' && ! /*#__PURE__*/React__default['default'].isValidElement(element)) {
        throw new Error("Invalid React element created from " + this.constructor.name + ".");
      }
    }

    return element;
  }
  /**
   * Trigger the actual pattern match and package the matched
   * response through a callback.
   */
  ;

  _proto4.doMatch = function doMatch(string, pattern, callback, isVoid) {
    if (isVoid === void 0) {
      isVoid = false;
    }

    return match(string, pattern, callback, isVoid);
  }
  /**
   * Callback triggered before parsing.
   */
  ;

  _proto4.onBeforeParse = function onBeforeParse(content, props) {
    return content;
  }
  /**
   * Callback triggered after parsing.
   */
  ;

  _proto4.onAfterParse = function onAfterParse(content, props) {
    return content;
  }
  /**
   * Replace the match with a React element based on the matched token and optional props.
   */
  ;

  return Matcher;
}();
/**
 * @copyright   2016-2019, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */


exports.ALLOWED_TAG_LIST = ALLOWED_TAG_LIST;
exports.ATTRIBUTES = ATTRIBUTES;
exports.ATTRIBUTES_TO_PROPS = ATTRIBUTES_TO_PROPS;
exports.BANNED_TAG_LIST = BANNED_TAG_LIST;
exports.Element = Element;
exports.FILTER_ALLOW = FILTER_ALLOW;
exports.FILTER_CAST_BOOL = FILTER_CAST_BOOL;
exports.FILTER_CAST_NUMBER = FILTER_CAST_NUMBER;
exports.FILTER_DENY = FILTER_DENY;
exports.FILTER_NO_CAST = FILTER_NO_CAST;
exports.Filter = Filter;
exports.Markup = Markup;
exports.Matcher = Matcher;
exports.Parser = Parser;
exports.TAGS = TAGS;
exports.TYPE_EMBEDDED = TYPE_EMBEDDED;
exports.TYPE_FLOW = TYPE_FLOW;
exports.TYPE_HEADING = TYPE_HEADING;
exports.TYPE_INTERACTIVE = TYPE_INTERACTIVE;
exports.TYPE_PALPABLE = TYPE_PALPABLE;
exports.TYPE_PHRASING = TYPE_PHRASING;
exports.TYPE_SECTION = TYPE_SECTION;
exports.default = Interweave;
exports.match = match;
//# sourceMappingURL=index.js.map
